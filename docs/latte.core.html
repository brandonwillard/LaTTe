<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte</span> <span class="project-version">0.4.1-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00_overview.html"><div class="inner"><span>Overview</span></div></a></li><li class="depth-1 "><a href="01_intro.html"><div class="inner"><span>Introduction to latte</span></div></a></li><li class="depth-1 "><a href="101_A_logician_dream.html"><div class="inner"><span>A Logician's Dream</span></div></a></li><li class="depth-1 "><a href="102_Lambda_the_ultimate.html"><div class="inner"><span>Lambda the ultimate</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="latte.core.html"><div class="inner"><span>latte.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte.core.html#var-.3D.3D.3E"><div class="inner"><span>==&gt;</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-assume"><div class="inner"><span>assume</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defaxiom"><div class="inner"><span>defaxiom</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-definition"><div class="inner"><span>definition</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-deflemma"><div class="inner"><span>deflemma</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defnotation"><div class="inner"><span>defnotation</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defprimitive"><div class="inner"><span>defprimitive</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defspecial"><div class="inner"><span>defspecial</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-defthm"><div class="inner"><span>defthm</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-forall"><div class="inner"><span>forall</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-have"><div class="inner"><span>have</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-lambda"><div class="inner"><span>lambda</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-mk-doc"><div class="inner"><span>mk-doc</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-proof"><div class="inner"><span>proof</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-qed"><div class="inner"><span>qed</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-term"><div class="inner"><span>term</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-term.3D"><div class="inner"><span>term=</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-try-proof"><div class="inner"><span>try-proof</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-type-check.3F"><div class="inner"><span>type-check?</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-type-of"><div class="inner"><span>type-of</span></div></a></li><li class="depth-1"><a href="latte.core.html#var-type-of.25"><div class="inner"><span>type-of%</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte.core</h1><div class="doc"><div class="markdown"><p>This namespace provides the top-level forms of the LaTTe framework. </p>
<p>Users (as opposed to developpers) of the framework should mostly depend on this namespace.</p></div></div><div class="public anchor" id="var-.3D.3D.3E"><h3>==&gt;</h3><div class="usage"><code>(==&gt; &amp; arguments)</code></div><div class="doc"><div class="markdown"><p>The function type, or equivalently logical implication.</p>
<p><code>(==&gt; A B)</code> is <code>(Π [x A] B)</code> where <code>x</code> does not occur free in <code>B</code>.</p>
<p>Implication is right associative:</p>
<p>’(==&gt; A B C) ≡ <code>(==&gt; A (==&gt; B C))</code>.</p></div></div></div><div class="public anchor" id="var-assume"><h3>assume</h3><h4 class="type">macro</h4><div class="usage"><code>(assume bindings &amp; body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-defaxiom"><h3>defaxiom</h3><h4 class="type">macro</h4><div class="usage"><code>(defaxiom &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of an axiom with the specified <code>name</code> (first argument)  an optional <code>docstring</code> (second argument), a vector of <code>parameters</code>  and the axiom statement (last argument).  Each parameter is a pair <code>[x T]</code> with <code>x</code> the parameter name and <code>T</code> its  type. </p>
<p>An axiom is accepted without a proof, and should thus be used with extra care. The LaTTe rule of thumb is that theorems should be favored, but axioms are sometimes required (e.g. the law of the excluded  middle) or more “reasonable” because of the proof length or complexity. In all cases the introduction of an axiom must be justified with strong  (albeit informal) arguments.</p></div></div></div><div class="public anchor" id="var-definition"><h3>definition</h3><h4 class="type">macro</h4><div class="usage"><code>(definition &amp; args)</code></div><div class="doc"><div class="markdown"><p>Defines a mathematical term composed of a <code>name</code>, and optional (but highly recommended) <code>docstring</code>, a vector of <code>parameters</code> and a <code>lambda-term</code> as definitional content.</p>
<p>An <code>ex-info</code> exception is thrown if the term cannot be defined.</p>
<p>Note that it is a Clojure <code>def</code>, the term is defined in the namespace where the <code>definition</code> form is invoked.</p></div></div></div><div class="public anchor" id="var-deflemma"><h3>deflemma</h3><h4 class="type">macro</h4><div class="usage"><code>(deflemma &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of a lemma, i.e. an auxiliary theorem. In LaTTe a lemma is private. To export a theorem the <a href="latte.core.html#var-defthm">defthm</a> form must be used instead.</p></div></div></div><div class="public anchor" id="var-defnotation"><h3>defnotation</h3><h4 class="type">macro</h4><div class="usage"><code>(defnotation def-name def-doc def-params &amp; def-body)</code></div><div class="doc"><div class="markdown"><p>Defines a new notation, which is a function called at parsing time. The result must be pair <code>[status u]</code>  with <code>status</code> either <code>:ok</code> (parsing successful) with <code>u</code> the term generated by the notation,  or <code>:ko</code> (parsing failed) and <code>u</code> is the error, a map with at least a key <code>:msg</code> explaining  the failure.</p>
<p>Be careful that the parser will be called recursively on the generated term, hence  recursive definitions must be handled with great care.</p></div></div></div><div class="public anchor" id="var-defprimitive"><h3>defprimitive</h3><h4 class="type">macro</h4><div class="usage"><code>(defprimitive &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of a primitive, i.e. an axiomatic definition (this is indeed a synonymous of <a href="latte.core.html#var-defaxiom">defaxiom</a>).</p></div></div></div><div class="public anchor" id="var-defspecial"><h3>defspecial</h3><h4 class="type">macro</h4><div class="usage"><code>(defspecial def-name def-doc def-params &amp; def-body)</code></div><div class="doc"><div class="markdown"><p>Defines a special term that is computed at typing and/or (delta-)normalization time.  The term is generated by an arbitrary function called with two arguments: the definitional environment <code>def-env</code> and the typing context <code>ctx</code> (with value <code>nil</code> at normalization time) plus the specific arguments of the special being defined. </p>
<p>By convention, all specials end with a percent character, cf. e.g. <a href="latte.core.html#var-type-of.25">type-of%</a>.</p>
<p>Remark: specials are generally used to simplify proofs, but should be used with care since they are arbitrary functions. The risk is limited, though, since they cannot  introduce inconsistencies, and may at worst generate a looping behavior.</p></div></div></div><div class="public anchor" id="var-defthm"><h3>defthm</h3><h4 class="type">macro</h4><div class="usage"><code>(defthm &amp; args)</code></div><div class="doc"><div class="markdown"><p>Declaration of a theorem of the specified <code>name</code> (first argument)  an optional <code>docstring</code> (second argument), a vector of <code>parameters</code> and the theorem proposition (last argument). Each parameter is a pair <code>[x T]</code> with <code>x</code> the parameter name and <code>T</code> its  type. </p>
<p>A theorem declared must then be demonstrated using the <a href="latte.core.html#var-proof">proof</a> form.</p></div></div></div><div class="public anchor" id="var-forall"><h3>forall</h3><div class="usage"><code>(forall bindings body)</code></div><div class="doc"><div class="markdown"><p>The <code>lambda</code> notation for product abstractions.</p>
<p>The expression <code>(forall [x T] U)</code> is the type of an abstraction of the form <code>(lambda [x T] e)</code> with <code>e</code>  of type <code>U</code> when <code>x</code> is of type <code>P</code>.</p>
<p>The low-level equivalent is <code>(Π [x T] U)</code>.</p>
<p>The extended notation <code>(forall [x y z T] U)</code> is equivalent to <code>(forall [x T] (forall [y T] (forall [z T] U)))</code>.</p></div></div></div><div class="public anchor" id="var-have"><h3>have</h3><h4 class="type">macro</h4><div class="usage"><code>(have &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-lambda"><h3>lambda</h3><div class="usage"><code>(lambda bindings body)</code></div><div class="doc"><div class="markdown"><p>The <code>lambda</code> notation for abstractions.</p>
<p>The simplest form is <code>(lambda [x T] e)</code> with as <code>bindings</code> the variable <code>x</code> of type <code>T</code>, and <code>e</code> as the abstraction <code>body</code>.</p>
<p>The low-level equivalent is <code>(λ [x T] e)</code>.</p>
<p>The extended notation <code>(lambda [x y z T] e)</code> is equivalent to <code>(lambda [x T] (lambda [y T] (lambda [z T] e)))</code>.</p></div></div></div><div class="public anchor" id="var-mk-doc"><h3>mk-doc</h3><div class="usage"><code>(mk-doc kind content explanation)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-proof"><h3>proof</h3><h4 class="type">macro</h4><div class="usage"><code>(proof thm-name method &amp; steps)</code></div><div class="doc"><div class="markdown"><p>Provides a proof of theorem named <code>thm-name</code> using the given proof <code>method</code> and <code>steps</code>.</p>
<p>There are for now two proof methods available:</p>
<ul>
  <li>
  <p>the <code>:term</code> method with one step: a direct proof/lambda-term inhabiting the theorem/type (based on the proof-as-term, proposition-as-type correspondances). This is a low-level proof method.</p></li>
  <li>
  <p>the <code>:script</code> method with a declarative proof script. It is a high-level (human-readable) proof method. A low-level proof term is synthetized from the script</p></li>
</ul></div></div></div><div class="public anchor" id="var-qed"><h3>qed</h3><h4 class="type">macro</h4><div class="usage"><code>(qed &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-term"><h3>term</h3><h4 class="type">macro</h4><div class="usage"><code>(term &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-term.3D"><h3>term=</h3><h4 class="type">macro</h4><div class="usage"><code>(term= ctx t1 t2)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-try-proof"><h3>try-proof</h3><h4 class="type">macro</h4><div class="usage"><code>(try-proof thm-name method &amp; steps)</code></div><div class="doc"><div class="markdown"><p>Tries (but does not register) a proof of theorem named <code>thm-name</code> using the given proof <code>method</code> and <code>steps</code>.</p></div></div></div><div class="public anchor" id="var-type-check.3F"><h3>type-check?</h3><h4 class="type">macro</h4><div class="usage"><code>(type-check? &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-type-of"><h3>type-of</h3><h4 class="type">macro</h4><div class="usage"><code>(type-of &amp; args)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-type-of.25"><h3>type-of%</h3><div class="usage"><code>(type-of% term)</code></div><div class="doc"><div class="markdown"><p>A special operator such that an occurrence of the term <code>(type-of% term)</code> is replaced by the <em>type</em> of <code>term</code>.</p></div></div></div></div></body></html>